<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Фінансовий Менеджер - FinManager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #FDFBF7; color: #4A4A4A; }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            height: 350px;
            max-height: 400px;
            margin: 0 auto;
        }
        @media (max-width: 768px) {
            .chart-container {
                height: 250px;
            }
        }
        .nav-item.active {
            @apply bg-stone-100 text-amber-600;
        }
        .card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .modal-open {
            overflow: hidden;
        }
        .form-input {
            @apply w-full p-3 border border-stone-300 rounded-lg focus:ring-amber-500 focus:border-amber-500 transition duration-150;
        }
        .form-label {
            @apply block text-sm font-medium text-stone-700 mb-1;
        }
    </style>
</head>
<body class="min-h-screen">

    <div id="addTransactionModal" class="fixed inset-0 bg-stone-900 bg-opacity-75 z-50 hidden items-center justify-center p-4" onclick="if(event.target.id === 'addTransactionModal') closeModal()">
        <div class="card w-full max-w-lg p-6">
            <h2 class="text-2xl font-bold text-stone-800 mb-6 border-b pb-3">Додати Нову Операцію</h2>
            <form id="addTransactionForm">
                <div class="mb-4">
                    <label for="transactionType" class="form-label">Тип</label>
                    <select id="transactionType" required class="form-input">
                        <option value="expense">Витрата (-)</option>
                        <option value="income">Дохід (+)</option>
                    </select>
                </div>
                <div class="mb-4">
                    <label for="transactionAmount" class="form-label">Сума (₴)</label>
                    <input type="number" id="transactionAmount" required min="0.01" step="0.01" class="form-input" placeholder="Наприклад, 1500.50">
                </div>
                <div class="mb-4">
                    <label for="transactionCategory" class="form-label">Категорія</label>
                    <select id="transactionCategory" required class="form-input"></select>
                </div>
                <div class="mb-4">
                    <label for="transactionDate" class="form-label">Дата</label>
                    <input type="date" id="transactionDate" required class="form-input" value="">
                </div>
                
                <div class="mb-4">
                    <label for="repeatFrequency" class="form-label">Повторювати</label>
                    <select id="repeatFrequency" class="form-input">
                        <option value="none">Не повторювати</option>
                        <option value="Monthly">Щомісячно (Напр., оренда)</option>
                        <option value="Yearly">Щорічно (Напр., страховка)</option>
                    </select>
                </div>
                
                <div class="mb-6">
                    <label for="transactionDescription" class="form-label">Опис (Необов'язково)</label>
                    <input type="text" id="transactionDescription" class="form-input" placeholder="Наприклад, Обід у кав'ярні">
                </div>
                <div class="flex justify-end space-x-3">
                    <button type="button" onclick="closeModal()" class="px-5 py-2 text-stone-600 bg-stone-200 rounded-lg hover:bg-stone-300 transition-colors">Скасувати</button>
                    <button type="submit" class="px-5 py-2 text-white bg-amber-600 rounded-lg hover:bg-amber-700 transition-colors"><i class="fa-solid fa-plus mr-2"></i> Додати</button>
                </div>
            </form>
        </div>
    </div>

    <div class="flex min-h-screen">
        <aside class="w-64 bg-white border-r border-stone-200 p-6 flex flex-col fixed h-full z-10">
            <h1 class="text-3xl font-bold text-stone-800 mb-10">FinManager</h1>
            <nav class="flex-grow">
                <a href="#" class="nav-item flex items-center p-3 rounded-xl transition-colors mb-2 active" data-view="dashboard">
                    <i class="fa-solid fa-chart-line w-5"></i>
                    <span class="ml-3 font-medium">Дашборд</span>
                </a>
                <a href="#" class="nav-item flex items-center p-3 rounded-xl transition-colors mb-2" data-view="transactions">
                    <i class="fa-solid fa-list-ul w-5"></i>
                    <span class="ml-3 font-medium">Операції</span>
                </a>
                <a href="#" class="nav-item flex items-center p-3 rounded-xl transition-colors mb-2" data-view="budgeting">
                    <i class="fa-solid fa-scale-balanced w-5"></i>
                    <span class="ml-3 font-medium">Бюджети</span>
                </a>
            </nav>
            <div class="mt-auto">
                <button onclick="openModal()" class="w-full py-3 text-white bg-amber-600 rounded-xl hover:bg-amber-700 transition-colors shadow-lg shadow-amber-500/50">
                    <i class="fa-solid fa-plus-circle mr-2"></i> Нова Операція
                </button>
                <div class="mt-4 text-center text-sm text-stone-500" id="auth-status">
                    Статус: <span class="text-red-500">Очікування авторизації</span>
                </div>
                <div class="mt-2 text-center text-xs text-stone-400" id="data-source-info">
                    Використовується Mock Data
                </div>
            </div>
        </aside>

        <main class="flex-grow p-8 md:p-10 ml-64">
            <header class="mb-8 flex flex-col md:flex-row justify-between items-center space-y-4 md:space-y-0">
                <h2 class="text-3xl font-bold text-stone-800" id="view-title">Дашборд</h2>
                <div class="flex items-center space-x-4 w-full md:w-auto">
                    <div class="relative w-full md:w-64">
                        <input type="text" id="searchFilter" placeholder="Пошук за описом..." class="form-input pr-10 bg-white">
                        <i class="fa-solid fa-magnifying-glass absolute right-3 top-1/2 transform -translate-y-1/2 text-stone-400"></i>
                    </div>
                </div>
            </header>

            <div id="dashboard-view" class="view">
                <div id="kpi-cards" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                    </div>

                <div class="grid grid-cols-1 lg:grid-cols-5 gap-6">
                    <div class="lg:col-span-3 card p-6">
                        <h3 class="text-xl font-semibold mb-6 text-stone-800">Аналіз Доходів та Витрат</h3>
                        <div class="chart-container">
                            <canvas id="barChart"></canvas>
                        </div>
                    </div>

                    <div class="lg:col-span-2 card p-6">
                        <div id="category-analysis-content">
                            </div>
                    </div>
                </div>
            </div>

            <div id="transactions-view" class="view hidden">
                <div class="card p-6 mb-8">
                    <h3 class="text-xl font-semibold mb-4 text-stone-800">Фільтри</h3>
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                        <div>
                            <label for="typeFilter" class="form-label">Тип</label>
                            <select id="typeFilter" class="form-input">
                                <option value="all">Всі</option>
                                <option value="income">Дохід</option>
                                <option value="expense">Витрата</option>
                            </select>
                        </div>
                        <div>
                            <label for="categoryFilter" class="form-label">Категорія</label>
                            <select id="categoryFilter" class="form-input">
                                <option value="all">Всі</option>
                                </select>
                        </div>
                        <div>
                            <label for="sortOrder" class="form-label">Сортування</label>
                            <select id="sortOrder" class="form-input" onchange="applyFilters()">
                                <option value="dateDesc">За датою (Новіші)</option>
                                <option value="dateAsc">За датою (Старіші)</option>
                                <option value="amountDesc">За сумою (Спадання)</option>
                                <option value="amountAsc">За сумою (Зростання)</option>
                            </select>
                        </div>
                        <div>
                            <label for="monthFilter" class="form-label">Місяць</label>
                            <input type="month" id="monthFilter" class="form-input" onchange="applyFilters()">
                        </div>
                    </div>
                </div>

                <div class="card p-6">
                    <h3 class="text-xl font-semibold mb-4 text-stone-800">Таблиця Операцій</h3>
                    <div class="overflow-x-auto">
                        <table class="min-w-full divide-y divide-stone-200">
                            <thead class="bg-stone-50">
                                <tr>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-stone-500 uppercase tracking-wider">Дата</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-stone-500 uppercase tracking-wider">Тип</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-stone-500 uppercase tracking-wider">Категорія</th>
                                    <th class="px-6 py-3 text-left text-xs font-medium text-stone-500 uppercase tracking-wider">Опис</th>
                                    <th class="px-6 py-3 text-right text-xs font-medium text-stone-500 uppercase tracking-wider">Сума (₴)</th>
                                    <th class="px-6 py-3 text-right text-xs font-medium text-stone-500 uppercase tracking-wider">Дії</th>
                                </tr>
                            </thead>
                            <tbody id="transactionsTableBody" class="bg-white divide-y divide-stone-200">
                                </tbody>
                        </table>
                    </div>
                    <div id="paginationControls" class="flex justify-between items-center mt-4">
                        <button onclick="changePage(-1)" class="px-3 py-1 bg-stone-200 rounded-lg hover:bg-stone-300 transition-colors" id="prevPageBtn">Попередня</button>
                        <span id="pageInfo" class="text-sm text-stone-600">Сторінка 1 з 1</span>
                        <button onclick="changePage(1)" class="px-3 py-1 bg-stone-200 rounded-lg hover:bg-stone-300 transition-colors" id="nextPageBtn">Наступна</button>
                    </div>
                </div>
            </div>
            
            <div id="budgeting-view" class="view hidden">
                <div class="card p-6 mb-8">
                    <h3 class="text-xl font-semibold mb-4 text-stone-800">Налаштування Місячних Бюджетів</h3>
                    <p class="text-stone-600 mb-6">Встановіть максимальні суми витрат для кожної категорії на поточний місяць. Залишіть поле пустим, щоб видалити бюджет.</p>
                    <form id="budgetForm" class="grid grid-cols-1 md:grid-cols-3 gap-6" onsubmit="saveBudgets(event)">
                        <div id="budgetFieldsContainer" class="md:col-span-3 grid grid-cols-1 md:grid-cols-3 gap-6">
                            </div>
                        <div class="md:col-span-3 pt-4 border-t border-stone-200 flex justify-end">
                            <button type="submit" class="px-5 py-2 text-white bg-emerald-600 rounded-lg hover:bg-emerald-700 transition-colors">
                                <i class="fa-solid fa-save mr-2"></i> Зберегти Бюджети
                            </button>
                        </div>
                    </form>
                </div>
                
                <div class="card p-6">
                    <h3 class="text-xl font-semibold mb-4 text-stone-800">Поточне Використання Бюджету</h3>
                    <div id="budgetingAnalysisContent">
                         </div>
                </div>
            </div>

        </main>
    </div>

    <script>
        // --- CONSTANTS ---
        const MOCK_CATEGORIES = ['Зарплата', 'Інвестиції', 'Оренда', 'Їжа', 'Транспорт', 'Комунальні', 'Дозвілля', 'Одяг', 'Здоров\'я', 'Інше'];
        const CATEGORIES = {
            'income': ['Зарплата', 'Інвестиції', 'Подарунки', 'Інше'],
            'expense': ['Оренда', 'Їжа', 'Транспорт', 'Комунальні', 'Дозвілля', 'Одяг', 'Здоров\'я', 'Інше']
        };

        // --- STATE & DATA ---
        let state = {
            user: null, // User object (e.g., from Firebase Auth)
            isMockMode: true, // If true, use mock data and skip Firebase setup
            transactions: [], // All transactions loaded from the source
            // NEW FEATURE: Recurring Transactions and Budgets
            recurringTransactions: [], // Definitions of monthly/yearly transactions
            budgets: {}, // { 'Їжа': 5000, 'Транспорт': 1000, ... }
            currentPage: 1,
            transactionsPerPage: 10,
            filteredTransactions: [],
        };

        // Chart.js instances
        let barChartInstance = null;
        let pieChartInstance = null;
        
        // Helper for currency formatting
        const formatter = new Intl.NumberFormat('uk-UA', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        
        // Helper to generate unique client-side IDs
        const generateUniqueId = () => Date.now().toString(36) + Math.random().toString(36).substring(2);

        // --- MOCK DATA (for isMockMode = true) ---
        function generateMockData() {
            const mockTransactions = [];
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();
            
            // Function to generate a random date in a given month/year
            const getRandomDate = (month, year) => {
                const day = Math.floor(Math.random() * 28) + 1;
                return `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            };

            // Generate transactions for Current Month
            for (let i = 0; i < 40; i++) {
                const type = Math.random() < 0.3 ? 'income' : 'expense';
                const categoryList = CATEGORIES[type];
                const category = categoryList[Math.floor(Math.random() * categoryList.length)];
                const amount = parseFloat((Math.random() * (type === 'income' ? 10000 : 5000) + (type === 'income' ? 5000 : 100)).toFixed(2));
                
                mockTransactions.push({
                    id: generateUniqueId(),
                    type: type,
                    amount: amount,
                    category: category,
                    description: `${type === 'income' ? 'Отримання' : 'Сплата'} за ${category}`,
                    date: getRandomDate(currentMonth, currentYear),
                    timestamp: new Date().getTime() - (i * 1000000)
                });
            }

            // Generate transactions for Previous Month
            const prevMonthDate = new Date();
            prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
            const prevMonth = prevMonthDate.getMonth();
            const prevYear = prevMonthDate.getFullYear();

            for (let i = 0; i < 30; i++) {
                 const type = Math.random() < 0.3 ? 'income' : 'expense';
                const categoryList = CATEGORIES[type];
                const category = categoryList[Math.floor(Math.random() * categoryList.length)];
                const amount = parseFloat((Math.random() * (type === 'income' ? 9000 : 4500) + (type === 'income' ? 4000 : 50)).toFixed(2));
                
                mockTransactions.push({
                    id: generateUniqueId(),
                    type: type,
                    amount: amount,
                    category: category,
                    description: `Попередня операція за ${category}`,
                    date: getRandomDate(prevMonth, prevYear),
                    timestamp: new Date().getTime() - (i * 1000000) - (30 * 24 * 60 * 60 * 1000)
                });
            }
            
            // NEW FEATURE: Mock Recurring Transactions
            const mockRecurring = [
                 { id: 'rtx1', type: 'expense', amount: 8000.00, category: 'Оренда', description: 'Оренда квартири', repeat: 'Monthly', startDate: getRandomDate(prevMonth, prevYear) },
                 { id: 'rtx2', type: 'income', amount: 35000.00, category: 'Зарплата', description: 'Основна зарплата', repeat: 'Monthly', startDate: getRandomDate(prevMonth, prevYear) },
            ];

            // NEW FEATURE: Mock Budgets
            const mockBudgets = {
                'Їжа': 7000,
                'Транспорт': 1500,
                'Дозвілля': 3000,
            };

            return { mockTransactions, mockRecurring, mockBudgets };
        }

        function initFirebase() {
            // NOTE: У реальному проєкті тут має бути код ініціалізації Firebase, 
            // завантаження конфігурації та підключення до Firestore.
            // Для цілей цього єдиного файлу, ми імітуємо завантаження даних.

            const authStatus = document.getElementById('auth-status');
            const sourceInfo = document.getElementById('data-source-info');
            
            // Імітація успішної авторизації
            state.user = { uid: 'mockUserId123' };
            authStatus.innerHTML = 'Статус: <span class="text-emerald-500">Авторизовано (Mock)</span>';
            sourceInfo.textContent = 'Використовується Mock Data';

            // Імітація завантаження даних
            const { mockTransactions, mockRecurring, mockBudgets } = generateMockData();
            state.transactions = mockTransactions;
            state.recurringTransactions = mockRecurring;
            state.budgets = mockBudgets;

            // NEW FEATURE: Process recurring transactions on load
            processRecurringTransactions(); 
            
            // Після завантаження даних - оновлюємо UI
            renderUI();
        }

        // --- MODAL & UI CONTROL ---
        function openModal() {
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('transactionDate').value = today;
            document.getElementById('addTransactionModal').classList.remove('hidden');
            document.getElementById('addTransactionModal').classList.add('flex');
            document.body.classList.add('modal-open');
        }

        function closeModal() {
            document.getElementById('addTransactionModal').classList.add('hidden');
            document.getElementById('addTransactionModal').classList.remove('flex');
            document.body.classList.remove('modal-open');
            document.getElementById('addTransactionForm').reset();
        }

        function switchView(viewName) {
            document.querySelectorAll('.view').forEach(view => {
                view.classList.add('hidden');
            });
            document.getElementById(`${viewName}-view`).classList.remove('hidden');

            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            document.querySelector(`.nav-item[data-view="${viewName}"]`).classList.add('active');
            
            // Set title and trigger specific renders
            const titleMap = {
                'dashboard': 'Дашборд',
                'transactions': 'Операції',
                'budgeting': 'Бюджети'
            };
            document.getElementById('view-title').textContent = titleMap[viewName];

            if (viewName === 'transactions') {
                applyFilters(); // Ensure transaction table is rendered
            } else if (viewName === 'dashboard') {
                renderDashboard();
            } else if (viewName === 'budgeting') {
                renderBudgets();
                renderBudgetingAnalysis();
            }
        }

        function populateCategorySelects() {
            const categorySelect = document.getElementById('transactionCategory');
            const filterCategorySelect = document.getElementById('categoryFilter');

            // Clear existing options
            categorySelect.innerHTML = '';
            filterCategorySelect.innerHTML = '<option value="all">Всі</option>';

            const allCategories = [...new Set([...CATEGORIES.income, ...CATEGORIES.expense])].sort();

            allCategories.forEach(category => {
                const option = document.createElement('option');
                option.value = category;
                option.textContent = category;
                categorySelect.appendChild(option.cloneNode(true));
                filterCategorySelect.appendChild(option);
            });
        }
        
        function renderUI() {
            populateCategorySelects();
            renderDashboard();
            applyFilters();
        }

        // --- TRANSACTION LOGIC ---
        
        // NEW FEATURE: Logic for Recurring Transactions
        function processRecurringTransactions() {
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();
            
            // Копія, щоб уникнути зміни під час ітерації
            const transactionsToAdd = []; 

            state.recurringTransactions.forEach(rtx => {
                const startDate = new Date(rtx.startDate);
                let nextDate = new Date(rtx.startDate); // Start from the defined start date

                while (nextDate.getTime() <= today.getTime()) {
                    
                    // Check if the transaction for this period is already added to actual transactions
                    const isAlreadyAdded = state.transactions.some(t => {
                        const tDate = new Date(t.date);
                        // Check if it's the right recurring source and the right month/year
                        return t.recurringId === rtx.id && 
                               tDate.getMonth() === nextDate.getMonth() && 
                               tDate.getFullYear() === nextDate.getFullYear();
                    });
                    
                    // If not added AND the recurrence is within the current period or in the past
                    if (!isAlreadyAdded) {
                         const newTransaction = {
                            ...rtx,
                            id: generateUniqueId(), // New unique ID for the generated transaction
                            recurringId: rtx.id, // Link to the recurring definition
                            // Use the date from the recurrence calculation
                            date: nextDate.toISOString().split('T')[0], 
                            timestamp: nextDate.getTime()
                        };
                        delete newTransaction.repeat; 
                        delete newTransaction.startDate;
                        
                        transactionsToAdd.push(newTransaction);
                        
                        // [FIREBASE TODO]: У реальному проєкті тут потрібно зберегти нову транзакцію у колекцію 'transactions'
                    }

                    // Calculate the date for the next potential recurrence
                    if (rtx.repeat === 'Monthly') {
                        // Move to the same day in the next month
                        nextDate.setMonth(nextDate.getMonth() + 1);
                    } else if (rtx.repeat === 'Yearly') {
                        // Move to the same day in the next year
                        nextDate.setFullYear(nextDate.getFullYear() + 1);
                    } else {
                        break; 
                    }
                    
                    // Safety break if somehow recurrence jumps too far ahead
                    if (nextDate.getTime() > today.getTime() + (31 * 24 * 60 * 60 * 1000)) { 
                        break;
                    }
                }
            });
            
            // Add all generated transactions to the state
            state.transactions.push(...transactionsToAdd);
        }

        function submitNewTransaction(e) {
            e.preventDefault();
            
            const type = document.getElementById('transactionType').value;
            const amount = parseFloat(document.getElementById('transactionAmount').value);
            const category = document.getElementById('transactionCategory').value;
            const date = document.getElementById('transactionDate').value;
            const description = document.getElementById('transactionDescription').value || '';
            
            // NEW FEATURE: Get recurrence frequency
            const repeat = document.getElementById('repeatFrequency').value;

            if (repeat !== 'none') {
                // Save as a recurring transaction definition
                const newRecurringTx = {
                    id: generateUniqueId(),
                    uid: state.user.uid,
                    timestamp: new Date(date).getTime(),
                    date: date, // 'date' acts as 'startDate' for recurring
                    type: type,
                    amount: amount,
                    category: category,
                    description: description,
                    repeat: repeat, // 'Monthly' or 'Yearly'
                    startDate: date 
                };
                
                state.recurringTransactions.push(newRecurringTx);
                // [FIREBASE TODO]: Save newRecurringTx to a 'recurring_transactions' collection
                
                // Immediately process to add the first instance to transactions if it's for the current month/year
                processRecurringTransactions();
                
            } else {
                // Save as a normal transaction
                const newTransaction = {
                    id: generateUniqueId(),
                    uid: state.user.uid,
                    timestamp: new Date(date).getTime(),
                    date: date,
                    type: type,
                    amount: amount,
                    category: category,
                    description: description,
                };
                
                state.transactions.push(newTransaction);
                // [FIREBASE TODO]: Save newTransaction to the 'transactions' collection
            }

            // Update UI
            closeModal();
            renderUI(); 
        }

        function deleteTransaction(transactionId) {
            if (confirm('Ви впевнені, що хочете видалити цю операцію?')) {
                // Find and delete from state.transactions
                const initialLength = state.transactions.length;
                state.transactions = state.transactions.filter(t => t.id !== transactionId);

                if (initialLength === state.transactions.length) {
                    // It might be a recurring definition (though usually users delete generated)
                    state.recurringTransactions = state.recurringTransactions.filter(t => t.id !== transactionId);
                }
                
                // [FIREBASE TODO]: Delete the transaction/recurring def from Firestore

                renderUI(); // Re-render everything
            }
        }
        
        function applyFilters() {
            const type = document.getElementById('typeFilter').value;
            const category = document.getElementById('categoryFilter').value;
            const search = document.getElementById('searchFilter').value.toLowerCase();
            const sortOrder = document.getElementById('sortOrder').value;
            const monthValue = document.getElementById('monthFilter').value; // YYYY-MM

            let filtered = state.transactions.slice(); // Copy of all transactions

            // 1. Month Filter
            if (monthValue) {
                filtered = filtered.filter(t => t.date.startsWith(monthValue));
            }

            // 2. Type Filter
            if (type !== 'all') {
                filtered = filtered.filter(t => t.type === type);
            }

            // 3. Category Filter
            if (category !== 'all') {
                filtered = filtered.filter(t => t.category === category);
            }
            
            // 4. Search Filter (by description)
            if (search) {
                filtered = filtered.filter(t => t.description.toLowerCase().includes(search));
            }

            // 5. Sorting
            filtered.sort((a, b) => {
                const aVal = a.amount;
                const bVal = b.amount;
                const aDate = new Date(a.date).getTime();
                const bDate = new Date(b.date).getTime();

                switch (sortOrder) {
                    case 'dateDesc': return bDate - aDate;
                    case 'dateAsc': return aDate - bDate;
                    case 'amountDesc': return bVal - aVal;
                    case 'amountAsc': return aVal - bVal;
                    default: return bDate - aDate;
                }
            });

            state.filteredTransactions = filtered;
            state.currentPage = 1; // Reset to first page after filtering
            renderTransactionsTable(filtered);
        }
        
        function renderTransactionsTable(transactions) {
            const tbody = document.getElementById('transactionsTableBody');
            tbody.innerHTML = '';
            
            const start = (state.currentPage - 1) * state.transactionsPerPage;
            const end = start + state.transactionsPerPage;
            const paginatedTransactions = transactions.slice(start, end);

            paginatedTransactions.forEach(t => {
                const isExpense = t.type === 'expense';
                const sign = isExpense ? '-' : '+';
                const color = isExpense ? 'text-rose-600' : 'text-emerald-600';
                
                // Check if it's a generated recurring transaction
                const recurringIcon = t.recurringId ? `<i class="fa-solid fa-repeat text-blue-400 mr-1" title="Повторювана операція"></i>` : '';

                const row = `
                    <tr class="hover:bg-stone-50 transition-colors">
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-stone-500">${t.date}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium ${color}">${t.type === 'income' ? 'Дохід' : 'Витрата'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-stone-700">${t.category}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-stone-700">${recurringIcon}${t.description || '—'}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-semibold text-right ${color}">${sign} ${formatter.format(t.amount)}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-right text-sm font-medium">
                            <button onclick="deleteTransaction('${t.id}')" class="text-rose-600 hover:text-rose-900 transition-colors">
                                <i class="fa-solid fa-trash-can"></i>
                            </button>
                        </td>
                    </tr>
                `;
                tbody.innerHTML += row;
            });

            // Update Pagination
            const totalPages = Math.ceil(transactions.length / state.transactionsPerPage);
            document.getElementById('pageInfo').textContent = `Сторінка ${state.currentPage} з ${totalPages || 1}`;
            document.getElementById('prevPageBtn').disabled = state.currentPage <= 1;
            document.getElementById('nextPageBtn').disabled = state.currentPage >= totalPages;
        }

        function changePage(delta) {
            const totalPages = Math.ceil(state.filteredTransactions.length / state.transactionsPerPage);
            const newPage = state.currentPage + delta;
            
            if (newPage >= 1 && newPage <= totalPages) {
                state.currentPage = newPage;
                renderTransactionsTable(state.filteredTransactions);
            }
        }
        
        // --- DASHBOARD & ANALYSIS ---
        
        function renderDashboard() {
            renderKpiCards();
            updateCharts();
            renderCategoryAnalysis(); 
        }

        // NEW FEATURE: KPI Comparison with Previous Month
        function calculateKpi() {
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();

            // 1. Фільтрація та агрегація для заданого місяця
            const getMonthlyKpi = (month, year) => {
                const transactions = state.transactions.filter(t => {
                    const date = new Date(t.date);
                    return date.getMonth() === month && date.getFullYear() === year;
                });

                const totalIncome = transactions
                    .filter(t => t.type === 'income')
                    .reduce((sum, t) => sum + t.amount, 0);

                const totalExpense = transactions
                    .filter(t => t.type === 'expense')
                    .reduce((sum, t) => sum + t.amount, 0);

                return { totalIncome, totalExpense, balance: totalIncome - totalExpense };
            };

            // 2. Визначення попереднього місяця
            const prevMonthDate = new Date();
            prevMonthDate.setMonth(prevMonthDate.getMonth() - 1);
            const prevMonth = prevMonthDate.getMonth();
            const prevYear = prevMonthDate.getFullYear();

            const current = getMonthlyKpi(currentMonth, currentYear);
            const previous = getMonthlyKpi(prevMonth, prevYear);

            // 3. Розрахунок відмінностей
            const calculateChange = (currentVal, previousVal) => {
                if (previousVal === 0) {
                    if (currentVal === 0) return 0;
                    // Якщо попередній місяць 0, а поточний > 0, вважаємо 100% зростання (або Нові дані)
                    return currentVal > 0 ? 100 : 0; 
                }
                return ((currentVal - previousVal) / previousVal) * 100;
            };

            return {
                // Поточні дані
                currentIncome: current.totalIncome,
                currentExpense: current.totalExpense,
                currentBalance: current.balance,
                // Порівняння з попереднім місяцем
                incomeChange: calculateChange(current.totalIncome, previous.totalIncome),
                expenseChange: calculateChange(current.totalExpense, previous.totalExpense),
                balanceChange: calculateChange(current.balance, previous.balance)
            };
        }
        
        // NEW FEATURE: Render KPI Cards with Comparison
        function renderKpiCards() {
            const { 
                currentIncome, currentExpense, currentBalance,
                incomeChange, expenseChange, balanceChange 
            } = calculateKpi();

            const cardsContainer = document.getElementById('kpi-cards');

            // Хелпер для форматування змін
            const formatChange = (change, isExpense) => {
                // Для витрат позитивна зміна (більше витрат) є 'негативною'
                const displayChange = isExpense ? -change : change;
                
                const isPositive = displayChange >= 0;
                const icon = isPositive ? 'fa-arrow-up' : 'fa-arrow-down';
                // Витрати: зелений = зменшення (негативна зміна), червоний = збільшення (позитивна зміна)
                const color = isPositive ? 'text-emerald-600' : 'text-rose-600';
                
                const sign = isPositive ? '+' : '';

                // Спеціальний випадок для початкових даних
                if (Math.abs(change) === 100 && (currentIncome > 0 || currentExpense > 0)) {
                    return `<span class="text-blue-600 font-medium"><i class="fa-solid fa-star mr-1"></i> Нові дані</span>`;
                }
                
                // Якщо баланс був 0, а став > 0
                if (change === 100 && currentBalance > 0 && currentIncome > 0 && currentExpense === 0) {
                     return `<span class="text-emerald-600 font-medium"><i class="fa-solid fa-star mr-1"></i> Значне зростання</span>`;
                }

                return `<span class="${color} font-medium">
                            <i class="fa-solid ${icon} mr-1"></i> 
                            ${sign}${Math.abs(displayChange).toFixed(1)}% 
                        </span>`;
            };

            cardsContainer.innerHTML = `
                <div class="card p-6 border-l-4 border-emerald-500">
                    <div class="flex justify-between items-start">
                        <div>
                            <p class="text-stone-500 text-sm font-medium">Доходи (місяць)</p>
                            <h3 class="text-2xl font-bold text-stone-800 mt-1">${formatter.format(currentIncome)} ₴</h3>
                        </div>
                        <div class="bg-emerald-100 p-2 rounded-lg text-emerald-600">
                            <i class="fa-solid fa-sack-dollar"></i>
                        </div>
                    </div>
                    <div class="mt-4 text-sm flex items-center gap-2">
                        ${formatChange(incomeChange, false)}
                        <span class="text-stone-500 text-xs"> порівняно з минулим міс.</span>
                    </div>
                </div>

                <div class="card p-6 border-l-4 border-rose-500">
                    <div class="flex justify-between items-start">
                        <div>
                            <p class="text-stone-500 text-sm font-medium">Витрати (місяць)</p>
                            <h3 class="text-2xl font-bold text-stone-800 mt-1">${formatter.format(currentExpense)} ₴</h3>
                        </div>
                        <div class="bg-rose-100 p-2 rounded-lg text-rose-600">
                            <i class="fa-solid fa-money-bill-transfer"></i>
                        </div>
                    </div>
                    <div class="mt-4 text-sm flex items-center gap-2">
                        ${formatChange(expenseChange, true)} 
                        <span class="text-stone-500 text-xs"> порівняно з минулим міс.</span>
                    </div>
                </div>

                <div class="card p-6 border-l-4 border-amber-500">
                    <div class="flex justify-between items-start">
                        <div>
                            <p class="text-stone-500 text-sm font-medium">Баланс (місяць)</p>
                            <h3 class="text-2xl font-bold text-stone-800 mt-1">${formatter.format(currentBalance)} ₴</h3>
                        </div>
                        <div class="bg-amber-100 p-2 rounded-lg text-amber-600">
                            <i class="fa-solid fa-piggy-bank"></i>
                        </div>
                    </div>
                    <div class="mt-4 text-sm flex items-center gap-2">
                        ${formatChange(balanceChange, false)}
                        <span class="text-stone-500 text-xs"> порівняно з минулим міс.</span>
                    </div>
                </div>
            `;
        }
        
        // NEW FEATURE: Render Category Analysis with Budgeting Progress
        function renderCategoryAnalysis() {
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();

            // Фільтруємо лише витрати за поточний місяць
            const monthlyExpenses = state.transactions.filter(t => {
                const date = new Date(t.date);
                return t.type === 'expense' && date.getMonth() === currentMonth && date.getFullYear() === currentYear;
            });

            // Агрегація витрат за категоріями
            const categoryMap = monthlyExpenses.reduce((map, t) => {
                map[t.category] = (map[t.category] || 0) + t.amount;
                return map;
            }, {});

            const sortedCategories = Object.entries(categoryMap).sort(([, a], [, b]) => b - a);
            const analysisContainer = document.getElementById('category-analysis-content');

            let analysisHtml = `
                <h3 class="text-xl font-semibold mb-4 text-stone-800">Структура Витрат (Місяць)</h3>
                <div id="budgeting-setup-link" class="mb-4">
                    <button onclick="switchView('budgeting')" class="text-sm text-blue-600 hover:text-blue-800 transition-colors">
                        <i class="fa-solid fa-scale-balanced mr-1"></i> Налаштувати Бюджети
                    </button>
                </div>
                <div class="space-y-4">
            `;

            if (sortedCategories.length === 0) {
                analysisHtml += `<p class="text-stone-500">Немає витрат за поточний місяць.</p>`;
            } else {
                for (const [category, amount] of sortedCategories) {
                    const budgetAmount = state.budgets[category] || 0;
                    const percentageSpent = budgetAmount > 0 ? (amount / budgetAmount) * 100 : 0;
                    const isOverBudget = budgetAmount > 0 && amount > budgetAmount;
                    const progressBarColor = isOverBudget ? 'bg-rose-500' : (percentageSpent > 80 ? 'bg-amber-500' : 'bg-emerald-500');

                    analysisHtml += `
                        <div class="mb-3">
                            <div class="flex justify-between items-center text-sm mb-1">
                                <span class="font-medium">${category}</span>
                                <span class="font-semibold text-stone-700">${formatter.format(amount)} ₴</span>
                            </div>
                            ${budgetAmount > 0 ? `
                                <div class="w-full bg-stone-200 rounded-full h-2.5">
                                    <div class="${progressBarColor} h-2.5 rounded-full" style="width: ${Math.min(100, percentageSpent)}%;"></div>
                                </div>
                                <div class="flex justify-between text-xs mt-1 text-stone-500">
                                    <span>Бюджет: ${formatter.format(budgetAmount)} ₴</span>
                                    ${isOverBudget ? `<span class="text-rose-600 font-medium">Перевитрата!</span>` : `<span class="text-stone-500">${percentageSpent.toFixed(0)}% використано</span>`}
                                </div>
                            ` : `<div class="text-xs text-stone-400 mt-1">Бюджет не встановлено.</div>`}
                        </div>
                    `;
                }
            }
            
            analysisHtml += `</div>`;
            analysisContainer.innerHTML = analysisHtml;
            renderBudgetingAnalysis(); // Also update analysis view
        }

        function getChartData() {
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();

            // Фільтруємо лише транзакції за поточний місяць
            const monthlyTransactions = state.transactions.filter(t => {
                const date = new Date(t.date);
                return date.getMonth() === currentMonth && date.getFullYear() === currentYear;
            });
            
            // Pie Chart Data (Category Expenses)
            const categoryMap = monthlyTransactions
                .filter(t => t.type === 'expense')
                .reduce((map, t) => {
                map[t.category] = (map[t.category] || 0) + t.amount;
                return map;
            }, {});

            // Bar Chart Data (Daily Totals)
            const dailyData = monthlyTransactions.reduce((map, t) => {
                const day = t.date;
                map[day] = map[day] || { income: 0, expense: 0 };
                if (t.type === 'income') {
                    map[day].income += t.amount;
                } else {
                    map[day].expense += t.amount;
                }
                return map;
            }, {});

            // Sort and prepare for Chart.js
            const barLabels = Object.keys(dailyData).sort();
            const incomeSeries = barLabels.map(day => dailyData[day].income);
            const expenseSeries = barLabels.map(day => dailyData[day].expense);

            return { categoryMap, barLabels, incomeSeries, expenseSeries };
        }

        function initCharts() {
            const barCtx = document.getElementById('barChart').getContext('2d');
            
            // Bar Chart Initialization (We'll use Bar Chart for daily income/expense and skip Pie Chart for simplicity)
            barChartInstance = new Chart(barCtx, {
                type: 'bar',
                data: {
                    labels: [], // Populated later
                    datasets: [
                        {
                            label: 'Дохід',
                            data: [], // Populated later
                            backgroundColor: 'rgba(16, 185, 129, 0.8)', // Emerald 500
                            borderColor: 'rgba(16, 185, 129, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Витрата',
                            data: [], // Populated later
                            backgroundColor: 'rgba(244, 63, 94, 0.8)', // Rose 500
                            borderColor: 'rgba(244, 63, 94, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true
                        }
                    }
                }
            });
            
            // Note: Pie Chart is removed from HTML for cleaner layout, using Bar Chart only
        }

        function updateCharts() {
             if (!barChartInstance) {
                initCharts();
                // Return if initialization happened to prevent error on first run
                if (!barChartInstance) return; 
            }

            const { barLabels, incomeSeries, expenseSeries } = getChartData();
            
            // Update Bar Chart Data
            barChartInstance.data.labels = barLabels;
            barChartInstance.data.datasets[0].data = incomeSeries;
            barChartInstance.data.datasets[1].data = expenseSeries;
            barChartInstance.update();
        }
        
        // --- NEW FEATURE: BUDGETING LOGIC ---

        function saveBudgets(e) {
            e.preventDefault();
            const form = document.getElementById('budgetForm');
            
            // Go through all fields in the container
            const container = document.getElementById('budgetFieldsContainer');
            state.budgets = {}; // Reset budgets

            container.querySelectorAll('input[type="number"]').forEach(input => {
                const category = input.name;
                const amount = parseFloat(input.value);

                if (!isNaN(amount) && amount > 0) {
                    state.budgets[category] = amount;
                }
            });

            // [FIREBASE TODO]: Save state.budgets to Firestore here
            
            // Update UI
            alert('Бюджети успішно збережено!');
            renderBudgets();
            renderCategoryAnalysis(); // Rerender dashboard view with new budgets
        }
        
        function renderBudgets() {
            const container = document.getElementById('budgetFieldsContainer');
            container.innerHTML = '';
            
            const allExpenseCategories = CATEGORIES.expense.sort();

            allExpenseCategories.forEach(category => {
                const currentBudget = state.budgets[category] || '';
                
                const html = `
                    <div>
                        <label for="budget-${category}" class="form-label">${category} (Макс. ₴)</label>
                        <input type="number" 
                               id="budget-${category}" 
                               name="${category}" 
                               value="${currentBudget}"
                               min="0"
                               step="0.01"
                               placeholder="Напр., 5000"
                               class="form-input">
                    </div>
                `;
                container.innerHTML += html;
            });
        }
        
        function renderBudgetingAnalysis() {
            const analysisContainer = document.getElementById('budgetingAnalysisContent');
            const today = new Date();
            const currentMonth = today.getMonth();
            const currentYear = today.getFullYear();

            const monthlyExpenses = state.transactions.filter(t => {
                const date = new Date(t.date);
                return t.type === 'expense' && date.getMonth() === currentMonth && date.getFullYear() === currentYear;
            });

            const categoryMap = monthlyExpenses.reduce((map, t) => {
                map[t.category] = (map[t.category] || 0) + t.amount;
                return map;
            }, {});
            
            let analysisHtml = '';
            const budgetedCategories = Object.keys(state.budgets).sort();
            
            if (budgetedCategories.length === 0) {
                 analysisHtml = `<p class="text-stone-500">Ви ще не налаштували жодного бюджету. Перейдіть до секції "Налаштування Місячних Бюджетів" вище.</p>`;
            } else {
                
                analysisHtml = `<div class="space-y-4">`;
                
                budgetedCategories.forEach(category => {
                    const budgetAmount = state.budgets[category];
                    const amountSpent = categoryMap[category] || 0;
                    const remaining = budgetAmount - amountSpent;
                    const percentageSpent = (amountSpent / budgetAmount) * 100;
                    const isOverBudget = remaining < 0;
                    
                    const progressBarColor = isOverBudget ? 'bg-rose-500' : (percentageSpent > 80 ? 'bg-amber-500' : 'bg-emerald-500');

                    analysisHtml += `
                        <div class="p-4 border rounded-lg ${isOverBudget ? 'border-rose-300 bg-rose-50' : 'border-stone-200'}">
                            <div class="flex justify-between items-center text-md mb-1">
                                <span class="font-bold text-stone-800">${category}</span>
                                <span class="font-semibold ${isOverBudget ? 'text-rose-600' : 'text-stone-700'}">${formatter.format(amountSpent)} ₴ / ${formatter.format(budgetAmount)} ₴</span>
                            </div>
                            
                            <div class="w-full bg-stone-200 rounded-full h-3">
                                <div class="${progressBarColor} h-3 rounded-full" style="width: ${Math.min(100, percentageSpent)}%;"></div>
                            </div>
                            
                            <div class="flex justify-between text-sm mt-2">
                                ${isOverBudget ? 
                                    `<span class="text-rose-600 font-medium">Перевитрата: ${formatter.format(Math.abs(remaining))} ₴</span>` : 
                                    `<span class="text-emerald-600 font-medium">Залишок: ${formatter.format(remaining)} ₴</span>`
                                }
                                <span class="text-stone-500">${percentageSpent.toFixed(1)}% використано</span>
                            </div>
                        </div>
                    `;
                });
                analysisHtml += `</div>`;
            }
            
            analysisContainer.innerHTML = analysisHtml;
        }


        // --- INIT ---
        document.addEventListener('DOMContentLoaded', () => {
            // Set today's date for transaction form
            document.getElementById('transactionDate').value = new Date().toISOString().split('T')[0];
            
            document.getElementById('addTransactionForm').addEventListener('submit', submitNewTransaction);
            document.getElementById('typeFilter').addEventListener('change', applyFilters);
            document.getElementById('categoryFilter').addEventListener('change', applyFilters);
            document.getElementById('searchFilter').addEventListener('input', applyFilters);
            
            // Add listeners for view switching
            document.querySelectorAll('.nav-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    e.preventDefault();
                    switchView(e.currentTarget.dataset.view);
                });
            });

            populateCategorySelects();
            
            switchView('dashboard'); 

            // Ініціалізація Firebase або Mock Mode
            initFirebase();
        });

    </script>
</body>
</html>
